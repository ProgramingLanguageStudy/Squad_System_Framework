# 📅 개발일지

---

## 2026-02-12 (수요일)

### 오늘 한 일

- **GameManager 정리 (30e76ab)**  
  GameManager.cs에서 불필요한 1줄 제거(주석 또는 미사용 참조 정리).

- **플레이어 프리펩화 (ab03932)**  
  플레이어 오브젝트를 `Assets/00_Prefabs/Player/Player.prefab`으로 분리해 프리팹화. 씬에 직접 두던 플레이어를 프리팹 인스턴스로 배치·재사용할 수 있게 함.

- **세이브/로드 시스템 기초 구현 (99ca1e9)**  
  - **GameManager**: SaveLoadSystem 노출 제거. 세이브/로드 진입점은 SaveManager, 데이터 수집·적용은 DataManager만 사용하도록 정리.  
  - **SaveManager**: `SaveLoadSystem`을 GameManager가 아닌 SaveManager가 직접 `new SaveSystem()`으로 보유. `Save()` / `LoadAndApply()`에서 DataManager.GatherSaveData, SaveSystem.Save/Load, DataManager.ApplySaveData 호출로 통일.  
  - **Player**: `PlayerSaveHandler` 참조 추가, Initialize 시 `_saveHandler.SetPlayer(this)` 호출. `GetSaveData()`로 위치·회전Y·현재 체력 반환, `ApplySaveData(PlayerSaveData)`로 로드 데이터 적용(Teleport, 회전, SetCurrentHpForLoad).  
  - **PlayerSaveHandler**: Awake에서 GetComponent로 Player 찾던 방식을 제거하고, `SetPlayer(Player)`로 주입받도록 변경. Gather/Apply는 `_player.GetSaveData()`, `_player.ApplySaveData(data.player)`만 호출해 책임을 Player에 위임.

- **싱글톤 수정 (ca2e146)**  
  Singleton<T>에서 “인스턴스 없으면 새 GameObject 생성” 동작을 **에디터 모드에서는 하지 않도록** 수정. `if (_instance == null && Application.isPlaying)` 조건 추가. 에디터에서 씬 열 때 불필요한 싱글톤 오브젝트가 생기는 것을 방지.

- **오류 수정 (f9aea51)**  
  - **GameManager.Awake**: SaveManager, DataManager를 Awake 시점에 한 번 접근해 즉시 생성(GetOrCreate)하도록 함. Start에서 로드가 동작하려면 이들이 이미 있어야 하므로, DontDestroyOnLoad 직후에 `var _ = SaveManager; var __ = DataManager;` 호출.  
  - **PlayerSaveHandler**: Gather/Apply 시 `_player == null`이면 `GetComponent<Player>()`로 한 번 더 시도한 뒤 진행. SetPlayer 호출 전에 DataManager가 Gather를 호출하는 경우 대비.

- **인벤토리에서 아이템 사용 기능 추가 (6fee6ae)**  
  - **Enum**: `ItemType` 추가 (Consumable, Material, Equipment).  
  - **Inventory**: `IItemUser _itemUser` 필드와 `SetItemUser(IItemUser)` 추가. `TryUseItem(slotIndex)` 구현 — 슬롯 유효·아이템 존재·ItemType.Consumable 체크 후 ConsumableItemData.ApplyTo(_itemUser) 호출하고 수량 1 차감.  
  - **InventoryPresenter**: Player 참조 추가, Awake에서 `_model.SetItemUser(_player.Model)`. View의 `OnUseRequested` 구독해 `HandleUseRequested`에서 `_model.TryUseItem(slotIndex)` 호출.  
  - **InventoryView**: `OnUseRequested` 이벤트 추가.  
  - **ItemSlot**: `IPointerClickHandler` 구현, 더블클릭(0.3초 이내 두 번째 클릭) 시 `OnUseRequested` 발동. `OnSwapRequested` 대신 사용 요청 이벤트 분리.  
  - **아이템 데이터 계층**: `ConsumableItemData`(abstract, ApplyTo), `HealItemData`(회복량 적용), `BuffItemData`(PlayerStatModifier + 지속시간, ApplyBuff), `EquipmentItemData`(StatModifier, 추후 장착용) 추가. ItemData에 ItemType 반환 및 소모품 적용 흐름 연결.

- **아이템 에셋 추가 (146f82b)**  
  - Apple → Apple_Heal, Mushroom → Mushroom_Heal(회복), Meat_AttackBuff(공격 버프), SprintPotion_MoveSpeedBuff(이동속도 버프) 등 ScriptableObject 에셋 추가.  
  - 텍스처(meat.png, potion.png) 및 Store 에셋(Fruits and Vegetables 등) 메타/리소스 추가.  
  - Play.unity 씬과 SaveData 참조 갱신.

- **아이템 획득 로그가 화면에 보이게 (7588c10)**  
  - **ItemPickupLog**: GameEvents.OnItemPickedUp 구독, 획득 시 ItemPickupSlot 프리팹을 Instantiate해 컨테이너에 추가하고 SetAsFirstSibling으로 위에 쌓이게 함.  
  - **ItemPickupSlot**: 아이콘 + "이름 x 수량" 표시, displayDuration(2.5초) 후 페이드 아웃(fadeOutDuration 0.3초) 후 Destroy. CanvasGroup으로 alpha 제어.  
  - **InventoryView**: 인벤토리 패널 열 때 ScrollRect가 있으면 verticalNormalizedPosition = 1f로 맨 위로 스크롤.  
  - **ItemSlot**: 빈 슬롯일 때 레이캐스트 끄기(스크롤 통과), 아이템 있을 때만 켜서 클릭/드래그 받도록 SetSlotRaycast(hasItem) 추가.

- **인벤토리 드롭 기능 구현·변경 (b8ad1ba)**  
  - **드롭 방식 변경**: 기존 “드롭 시 레이캐스트로 목표 슬롯 찾아 스왑”을 제거. “드롭 끝난 스크린 좌표”를 View에 넘기고, View가 **RectTransformUtility.ScreenPointToLocalPointInRectangle + rect.Contains**로 해당 좌표가 속한 슬롯 인덱스를 계산해 스왑하는 방식으로 통일.  
  - **Inventory**: Awake에서 슬롯 배열 초기화하던 것을 `Initialize()` 메서드로 분리. Presenter가 호출.  
  - **InventoryPresenter**: OnEnable에서 OnSwapRequested 대신 OnDropEnded 구독. HandleDropEnded(fromIndex, screenPosition)에서 View.GetSlotIndexAtPosition(screenPosition)으로 toIndex를 구한 뒤 toIndex >= 0 && toIndex != fromIndex일 때만 Model.SwapItems 호출.  
  - **InventoryView**: Start를 Initialize()로 바꾸고 Presenter가 Awake 후 호출. OnSwapRequested → OnDropEnded(Action<int, Vector2>). GetSlotIndexAtPosition(Vector2) 구현(모든 슬롯 RectTransform에 대해 스크린 좌표를 로컬로 변환 후 rect 포함 여부로 인덱스 반환).  
  - **ItemSlot**: OnSwapRequested 제거, OnDropEnded(fromIndex, eventData.position)로 변경. EndDrag 시 GetSlotAtPosition 같은 별도 레이캐스트 없이 좌표만 전달.

- **디버거 기능 추가 (babf8ad, 04aab21)**  
  - **신규**: PlayerDebugger, InventoryDebugger, EnemySpawnerDebugger 컴포넌트 및 각 CustomEditor 추가. EnemySpawner 전용 Editor는 제거하고 EnemySpawnerDebuggerEditor에서만 “적 생성” 버튼 제공.  
  - **PlayerDebuggerEditor**: 체력 풀회복 버튼. 04aab21에서 “현재 스탯” 블록 추가(체력, 사망, 이동속도, 공격력, 공격속도, 방어력), EditorApplication.update로 0.1초 간격 Repaint 해서 플레이 중 실시간 갱신. Find 제거 후 참조 없으면 로그만.  
  - **InventoryDebugger**: 단일 테스트 아이템 → AddItemEntry(itemData, amount) 리스트로 변경. CustomEditor에서 리스트를 수동 그려서 행마다 (ItemData 필드, Amount 필드, 추가 버튼) 한 줄로 배치. 아이템/수량은 에디터에서 미리 등록 가능, 추가 버튼만 플레이 모드에서 동작. Find 제거.  
  - **공통**: 모든 디버거에서 FindFirstObjectByType 제거, “인스펙터에서 반드시 참조 할당” 안내로 통일.  
  - **Docs**: 개발일지 템플릿(개발일지_템플릿.md), 2025-02-10 일지(개발일지_2025-02-10.md) 추가.

---

### 기술 메모 / 배운 점

- **세이브/로드 책임 분리**: SaveManager는 “언제 저장/로드할지”와 API만 담당하고, 실제 I/O는 SaveSystem(일반 클래스)이 담당. DataManager는 ISaveHandler들을 모아 Gather/Apply만 호출. Player의 위치·체력 등은 PlayerSaveHandler가 Player.GetSaveData() / ApplySaveData()에 위임하면, Player 쪽에서 Teleport·SetCurrentHpForLoad 등 세부 구현을 한 곳에서 관리할 수 있음.

- **싱글톤과 에디터**: Singleton이 에디터(비플레이)에서도 인스턴스가 없으면 GameObject를 만들어 버리면, 씬 저장 시 의도치 않은 오브젝트가 들어갈 수 있음. `Application.isPlaying` 체크로 “실행 중일 때만 자동 생성”으로 제한하는 게 안전함.

- **로드 타이밍**: SaveManager가 Start에서 LoadAndApply를 호출하려면, DataManager와 SaveSystem이 그 전에 준비돼 있어야 함. GameManager.Awake에서 SaveManager·DataManager를 한 번 접근해 GetOrCreate로 미리 생성해 두면, Start 시점에 로드가 정상 동작함.

- **인벤토리 드롭**: “드롭한 슬롯”과 “드롭 끝난 위치가 올라간 슬롯”을 구할 때, 레이캐스트 대신 “드롭 끝 좌표”를 View에 넘기고, View가 각 슬롯의 RectTransform에 대해 ScreenPointToLocalPointInRectangle + rect.Contains로 포함 여부를 판단하면 스크롤·레이아웃이 바뀌어도 일관되게 동작함. 슬롯 생성 순서와 인덱스를 한 곳(View)에서만 관리할 수 있어 유지보수에 유리함.

- **소모품/버프 아이템 구조**: ItemData를 Consumable / Equipment 등 타입으로 나누고, Consumable은 ApplyTo(IItemUser)로 처리하게 하면, Heal·Buff·기타 소모품을 같은 TryUseItem 흐름에서 확장 가능. IItemUser에 Heal, ApplyBuff 등만 정의해 두면 플레이어·NPC 등 다른 대상에도 같은 인터페이스로 적용할 수 있음.

- **Unity 인스펙터 실시간 표시**: 커스텀 에디터에서 런타임 값(스탯 등)을 “실시간”처럼 보이게 하려면, 값이 바뀔 때마다 인스펙터가 다시 그려져야 함. EditorApplication.update에서 주기적으로 Repaint()를 호출하면 되고, 0.1초 간격처럼 제한하면 부담을 줄이면서도 버프 지속시간 등 확인하기에 충분함.

- **에디터에서 리스트 한 줄 UI**: SerializedProperty로 리스트를 수동으로 그릴 때, GetArrayElementAtIndex(i)로 각 요소를 가져온 뒤 FindPropertyRelative로 자식 필드를 그리면, 기본 리스트(Element 0, 1 접기) 대신 “행마다 (필드, 필드, 버튼)” 형태로 배치할 수 있음. 적용 버튼은 플레이 모드에서만 활성화하고, 아이템/수량 필드는 에디터 모드에서도 편집 가능하게 두면 “미리 등록해 두고 플레이에서만 추가” 플로우를 만들 수 있음.

---

### 내일 할 일 (선택)
- 

### 기타
- 

---

*Git 로그 + diff 기준 정리 (2026-02-12 커밋만).*

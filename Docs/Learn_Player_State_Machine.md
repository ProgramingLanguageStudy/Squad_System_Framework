# 플레이어 상태머신 — 구조·역할·선택지 (학습·토론용)

> **목적**: 구현보다 **이해와 토론**. 플레이어 상태머신을 어떤 구조로 가져갈지, 왜 그렇게 쓰는지, 어떤 구조가 유리한지 등을 정리한 학습·공부 거리.

---

## 1. 상태머신이란 무엇인가

### 1.1 한 줄 요약

**“지금 캐릭터가 어떤 ‘모드’에 있는지 하나만 정하고, 그 모드에 맞는 동작만 하게 만드는 것”**이 상태머신의 핵심이다.

- 예: **Idle**일 때만 이동·공격 입력을 받고, **Attack** 중에는 이동 불가, **Roll** 중에는 모든 입력 무시.
- 매 프레임 “지금 뭘 할 수 있나?”를 **한 곳(현재 상태)**에서만 결정하면, if/else가 여러 스크립트에 흩어지지 않는다.

### 1.2 왜 쓰는가

| 문제 | 상태머신으로 해결 |
|------|------------------|
| “공격 중인데 또 공격 입력 들어오면?” | 현재 상태가 Attack이면 새 공격 요청을 받지 않거나, 큐에 넣거나, 상태가 정한 규칙대로 처리. |
| “구르는 중에 이동 입력이 들어오면?” | 현재 상태가 Roll이면 이동 로직을 아예 타지 않게 함. |
| “이동 가능 여부가 Player, Mover, Attacker에 흩어져 있음” | “이동 가능 여부 = 현재 상태가 Idle(또는 Move)인가?” 한 가지로 모을 수 있음. |

즉, **행동의 허용/금지와 전환 규칙을 한 곳(상태 + 전환 로직)에 모으기 위해** 쓴다.

---

## 2. 상태를 어떻게 표현할 것인가

### 2.1 enum 방식

```csharp
public enum PlayerState { Idle, Attacking, Rolling }
// 현재 상태만 저장하고, Update/입력 처리에서 switch 또는 if로 분기
```

- **장점**: 단순함, 타입 하나로 “지금 상태”만 표현.
- **단점**:  
  - 각 상태에서 **진입 시 할 일(애니 재생, 플래그 설정)**이 늘어나면 switch/if가 비대해짐.  
  - **상태별로 다른 Update 동작**을 넣으려면 매 프레임 `switch (currentState) { case Idle: ... case Attacking: ... }` 형태가 됨.  
  - 새 상태 추가 시 한 곳(enum + 모든 switch)을 고쳐야 함.

### 2.2 클래스 기반 (상태 = 클래스, Enter/Update/Exit)

```csharp
// 현재 상태가 객체. 진입 시 Enter(), 매 프레임 Update(), 빠져나갈 때 Exit()
public abstract class PlayerStateBase {
    public abstract void Enter();
    public abstract void Update();
    public abstract void Exit();
}
// IdleState, AttackState, RollState … 각각 한 파일
```

- **장점**:  
  - **상태 하나 = 클래스 하나**라서 책임이 나뉨.  
  - 새 상태 추가 = 새 클래스 추가 + 전환만 연결.  
  - Enter/Update/Exit로 “언제 무엇을 할지”가 명확함.  
  - 테스트·재사용 시 상태 단위로 볼 수 있음.
- **단점**: 파일/클래스 수가 늘어남. 단순한 게임에는 과할 수 있음.

**정리**: 상태가 2~3개고 분기 로직이 단순하면 enum으로도 충분. 상태가 늘어나거나 “진입/종료 시 할 일”이 많아지면 클래스 기반이 유리하다.

---

## 3. “전환”은 누가 결정하는가

여기서 **구조 선택**이 갈린다.

### 3.1 전환 요청 vs 전환 허용

- **전환 요청**: “공격하고 싶다”, “Idle로 돌아가라”처럼 **외부가 원하는 목표**를 말하는 것.
- **전환 허용**: “지금 Idle이니까 Attack으로 가도 된다”, “공격 애니가 끝났으니 Idle로 가도 된다”처럼 **실제로 바꿀지**를 판단하는 것.

상태머신은 보통 **“요청을 받고, 현재 상태와 규칙을 보고 허용되면 전환”**을 한다.

### 3.2 전환을 “어디서” 판단할 것인가

| 위치 | 설명 | 장점 | 단점 |
|------|------|------|------|
| **상태머신 내부** | RequestAttack() 안에서 “현재 Idle이면 Attack으로 전환” 판단 | 전환 규칙이 한 곳에 모임. 호출자는 “공격 요청”만 하면 됨. | 상태머신이 “어떤 상태에서 어떤 전환이 가능한지”를 다 알아야 함. |
| **호출자(Player/PlayScene)** | “Idle이면 RequestAttack() 호출”을 호출자에서 if로 처리 | 상태머신은 “요청만 받아서 전환”하는 얇은 역할만. | 전환 조건이 여러 곳(입력 처리, 애니 이벤트 등)에 흩어질 수 있음. |
| **상태 클래스 안** | IdleState.Update()에서 “공격 입력이 있었으면 Machine.RequestAttack()”처럼 상태가 전환 요청 | 상태 자신이 “이 상태에서 나갈 조건”을 가짐. | 입력을 상태가 알아야 해서, 입력과 상태가 결합됨. (일반적으로는 비추천) |

**실무에서 자주 쓰는 것**:  
- **전환 허용 판단은 상태머신**에 두고,  
- **외부(Player, PlayScene, 애니 이벤트)**는 “RequestAttack()”, “RequestIdle()”처럼 **의도만 전달**하는 방식.  
이렇게 하면 “Idle에서만 공격 가능” 같은 규칙이 상태머신 한 곳에 모인다.

---

## 4. 입력 → 행동으로 갈 때, “누가 먼저”인가

여기가 **컴포넌트 vs 상태 중심**으로 갈리는 부분이다.

### 4.1 방식 A: “행동 컴포넌트”가 먼저 (입력 → Attacker → 상태머신)

- 흐름: **공격 키 입력** → PlayScene이 **Attacker.TryAttack()** 호출 → Attacker가 **StateMachine.RequestAttack()** 호출.
- 의미: “공격”이라는 **행동**을 담당하는 컴포넌트(Attacker)가 **입력의 첫 반응자**이고, 그 다음에 상태 전환이 일어남.

**장점**:  
- “공격” 관련된 것(입력 반응, 애니 종료)이 Attacker 주변에 모일 수 있음.  
- 상태머신은 “전환만” 담당하는 느낌.

**단점**:  
- “공격할 수 있는지”를 Attacker가 알려면 상태머신을 들여다봐야 함.  
- 나중에 “구르기”, “스킬” 등이 생기면 **입력 → XX 컴포넌트 → 상태머신**이 계속 늘어남.  
- “지금 어떤 행동이 가능한가?”가 **여러 컴포넌트 + 상태머신**에 나뉨.

### 4.2 방식 B: “의도”를 한 곳에서 받고, 조건·전환은 상태머신 (입력 → Player → 상태머신)

- 흐름: **공격 키 입력** → PlayScene이 **Player.RequestAttack()** 호출 → Player는 **StateMachine.RequestAttack()**만 호출.  
  “지금 Idle인가?” 등 **조건 판단은 상태머신**이 RequestAttack() 안에서 처리.
- 의미: **“공격하고 싶다”는 의도**만 Player(또는 한 진입점)에서 받고, **가능 여부와 전환**은 상태머신이 책임진다.

**장점**:  
- “어떤 상태에서 어떤 전환이 허용되는지”가 **상태머신 한 곳**에 모임.  
- 새 행동(구르기, 스킬)을 추가해도 **Player.RequestRoll()**, **RequestSkill()** 같은 진입점만 늘리고, 조건은 상태머신에만 추가하면 됨.  
- PlayScene은 “어떤 키가 어떤 의도인지”만 알면 되고, “지금 그게 가능한지”는 몰라도 됨.

**단점**:  
- Player(또는 진입점)에 RequestXxx 메서드가 늘어남.  
- “공격” 로직이 Attacker와 상태머신에 나뉨 (애니 종료 → Idle은 Attacker, 전환 규칙은 상태머신).

### 4.3 비교 요약

| | A. 컴포넌트가 먼저 | B. 의도만 전달, 조건은 상태머신 |
|--|-------------------|----------------------------------|
| **진입점** | Attacker.TryAttack(), Mover.xxx, Roller.TryRoll()… | Player.RequestAttack(), RequestRoll()… |
| **조건·전환** | 상태머신이 알지만, “누가 요청했는지”에 따라 흩어질 수 있음 | 상태머신 한 곳에서 “현재 상태 + 요청 → 전환 여부” |
| **확장** | 행동마다 컴포넌트 + 그 컴포넌트가 상태머신 호출 | 행동마다 RequestXxx + 상태머신에 전환 규칙 추가 |

**학습용 정리**:  
- **상태 개수가 많아지고, “지금 뭘 할 수 있는지”를 한 곳에서 관리하고 싶다** → B가 유리.  
- **행동이 2~3개고, 각 행동이 자기 컴포넌트에 몰려 있는 게 읽기 좋다** → A도 가능.

### 4.4 정답이 있는가?

**“이거만이 정답이다”라고 할 수는 없다.** 프로젝트 규모, 팀 습관, 나중에 넣을 기능에 따라 A도 B도 타당할 수 있다.

다만 **“상태에 대한 책임은 상태머신이 진다”**는 이유로 상태머신을 도입했다면, 아래 선택이 잘 맞는다.

- **상태머신**: 전환 조건·허용 여부를 **상태머신이 담당**. (그래서 상태머신이 “상태”를 책임진다.)
- **플레이어**: 들어온 입력(의도)을 **전달만** 한다. `RequestAttack()`은 “공격하고 싶다는 의도 전달”이고, 가능 여부·전환은 상태머신이 처리.

즉, **정답은 없지만**, “상태 책임 = 상태머신, 플레이어 = 전달만”은 역할이 잘 나뉘고, 상태 규칙이 한 곳에 모이므로 **우리 프로젝트에서 택한 방향**으로 두면 된다. (구체적인 역할은 `Definition_Player_Structure.md` 참고.)

---

## 5. AttackState는 “공격 관련 모든 것”을 담당해야 하나?

공격 입력 → 상태머신이 Attack으로 전환한 뒤, **AttackState가 공격 구현·애니 실행·타격 판정 등 전부를 맡아야 하는지**는 설계 선택이다.

### 5.1 두 가지 스타일

| 스타일 | 상태가 하는 일 | 나머지는 누가? |
|--------|----------------|----------------|
| **Fat State (뚱뚱한 상태)** | 공격 애니 실행, 히트박스 켜기/끄기, 데미지 계산, 이펙트, 종료 판정까지 **다 상태 안에서** 처리. | 거의 없음. 상태가 다 함. |
| **Thin State (얇은 상태)** | “지금 공격 중이다”만 표현. **진입 시** 할 일만 최소로 (예: CanMove 끄기, 애니 트리거 한 번). **퇴장**은 외부(애니 이벤트 등)가 RequestIdle()로 알려줌. | 애니 재생·타이밍은 Animator, 타격 판정·데미지는 전용 컴포넌트나 애니 이벤트. |

### 5.2 우리가 쓰는 쪽: Thin State

지금 구조는 **Thin State**에 가깝다.

- **AttackState.Enter()**:  
  - “이동 불가” 설정 (`CanMove = false`).  
  - “공격 애니 재생해” 한 번만 요청 (`Player.Animator.Attack()`).  
- **AttackState.Update()**:  
  - 특별한 로직 없음. “언제 끝나는지”는 **애니메이션 이벤트**가 `EndAttack()` → `RequestIdle()`로 알려 줌.  
- **공격의 “구현”**(언제 히트박스가 켜지는지, 데미지, 이펙트)은 **AttackState 밖**에 둔다.  
  - 예: 애니메이션 이벤트에서 “지금 프레임에 타격 판정” 컴포넌트를 호출하거나, 별도 `PlayerCombat` 같은 컴포넌트가 “공격 중일 때만” 동작하도록 할 수 있음.

즉, **AttackState는 “공격 관련 모든 것”을 담당하지 않는다.**  
**“지금 공격 상태다” + “진입 시 할 최소한의 것(이동 차단, 애니 트리거)”**만 담당하고,  
실제 공격 구현(타격 판정, 데미지, 이펙트)은 다른 컴포넌트나 애니 이벤트에 두는 게 보통이다.

### 5.3 왜 Thin이 자주 쓰이는가

- **상태의 책임이 명확해짐**: 상태는 “지금 어떤 모드인가”와 “진입/퇴장 시 꼭 해야 할 것”만 담당.  
- **공격 로직 재사용**: 타격 판정·데미지는 다른 상태(스킬, 강공격)에서도 쓸 수 있으니, 상태가 아니라 전용 컴포넌트에 두기 좋음.  
- **테스트·분리**: “공격 상태 진입/퇴장”과 “실제 타격 처리”를 나눠서 검증하기 쉬움.

정리하면, **“공격 입력 → 플레이어가 상태머신에 전달 → 상태머신이 Attack으로 전환”**까지는 말씀하신 대로이고,  
**그 다음**에는 **AttackState는 “공격 모드 진입 + 진입 시 최소 처리”만 하고, 공격 구현·애니 세부·타격 판정 등은 별도 컴포넌트/이벤트에 두는 구조**가 일반적이다.

---

## 6. 상태머신이 “알아야 하는 것” vs “몰라도 되는 것”

설계할 때 도움이 되는 구분이다.

### 6.1 상태머신이 보통 아는 것

- **현재 상태** (어떤 상태 클래스/enum인지).
- **전환 규칙** (어떤 상태에서 RequestAttack / RequestIdle / … 을 받으면 어떤 상태로 바꿀지).
- **상태 인스턴스** (IdleState, AttackState 등)를 만들고 보관하고, Enter/Update/Exit를 호출할 대상.

### 5.2 상태머신이 몰라도 되는 것 (선택)

- **입력이 어디서 왔는지** (키보드, 네트워크, AI …).  
  → “RequestAttack()이 호출됐다”만 알면 됨.
- **애니메이션 세부** (어떤 클립인지, 블렌드 트리 구조).  
  → 상태는 “Player.Animator.Attack() 호출” 수준만 알면 되고, Animator 내부는 몰라도 됨.
- **이동 구현 세부** (NavMeshAgent인지, Rigidbody인지).  
  → “CanMove = false” 같은 플래그만 건드리고, 실제 이동 코드는 Mover가 담당.

이렇게 **상태머신은 “상태와 전환”에만 집중**하게 두면, 테스트와 확장이 쉬워진다.

---

## 6. 흐름 한번에 그리기

두 방식을 같은 다이어그램으로 보면 이렇게 대응된다.

```
[입력: 공격 키]
       │
       ▼
┌──────────────────────────────────────────────────────────┐
│  A: PlayScene → Attacker.TryAttack() → StateMachine.     │
│     RequestAttack()                                      │
│  B: PlayScene → Player.RequestAttack() → StateMachine.  │
│     RequestAttack()                                      │
└──────────────────────────────────────────────────────────┘
       │
       ▼
┌──────────────────┐     허용 시      ┌──────────────────┐
│  StateMachine     │ ──────────────► │  AttackState      │
│  (현재 Idle인가?)  │   전환          │  Enter(): 애니,   │
│  Yes → 전환       │                 │  CanMove=false    │
└──────────────────┘                 └──────────────────┘
       │
       │  (나중에) 애니메이션 이벤트: "공격 끝"
       ▼
  EndAttack() → RequestIdle() → IdleState로 전환
```

- **A**: “공격” 진입이 Attacker를 거침.  
- **B**: “공격” 진입이 Player를 거치고, 조건은 상태머신이 처리.

---

## 7. 더 공부해 보면 좋은 것들

- **Hierarchical State Machine (HSM)**: 상태 안에 다시 하위 상태가 있는 구조. (예: Movement 안에 Idle / Walk / Run.)
- **State + Behavior 분리**: 상태는 “지금 뭘 할 수 있나”만 정하고, 실제 이동/공격 연산은 별도 컴포넌트(Mover, Animator)에 두는 패턴. (지금 우리가 쓰는 방식과 비슷.)
- **전환 테이블**: 상태 × 이벤트(요청) → 다음 상태를 표로 두고, 코드는 그 표만 보고 전환하는 방식. 상태가 많을 때 유리.
- **애니메이션 드리븐**: 애니메이션 이벤트/스테이트 머신이 “이제 Idle로 돌아가라”를 알려 주고, 게임 로직 상태머신이 그에 맞춰 전환하는 방식. (지금 EndAttack → RequestIdle()이 이에 가깝다.)

---

## 8. 이 문서를 읽은 뒤 스스로 정리해 볼 질문

1. 우리 프로젝트에서 “전환 허용”은 어디에 두는 게 좋을까? (상태머신 vs 호출자)
2. 공격 말고 “구르기”를 추가한다면, 입력은 PlayScene에서 어디로 보낼까? (Player.RequestRoll() vs Roller.TryRoll())
3. 상태머신이 “입력”을 직접 읽는 구조는 왜 보통 피하는가?
4. enum 상태 vs 클래스 상태를, 우리 프로젝트 규모에서는 어떤 쪽이 더 맞을까?

---

*이 문서는 “정답”이 아니라 **구조 선택지와 트레이드오프**를 정리한 학습·토론용이다. 프로젝트에서 선택한 방식은 `Definition_Player_Structure.md` 등에 반영하면 된다.*

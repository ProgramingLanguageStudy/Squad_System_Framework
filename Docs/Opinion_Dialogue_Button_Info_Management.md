# 의견: 대화창 버튼 “정보”를 어떻게 관리할까

버튼 프리팹 하나를 두고, 대화를 띄울 때 **“버튼 몇 개, 위에서부터 뭘 보여줄지”** 정보를 넘기는 방식에서, 그 **정보를 어디서/무엇으로 관리할지**에 대한 정리.

---

## 1. 넘겨야 할 정보 (최소)

각 버튼마다:

- **표시 텍스트** (예: "호감도 선물증정", "퀘스트 제공", "대화 끝내기")
- **클릭 시 무슨 일을 할지** (액션 식별자 또는 콜백)

그리고 전체로:

- **버튼 개수** (또는 “버튼 정보 목록”의 길이)
- **순서** (위에서부터 → 배열/리스트 순서로 표현하면 됨)

---

## 2. “정보”를 누가 만드느냐

- **대화를 여는 쪽**이 “지금 이 NPC/이 대화에서는 이 버튼들이 필요하다”고 알고 있음.  
  → Npc.Interact 또는 DialogueManager.GetBestDialogue를 쓴 뒤, “이번에 쓸 버튼 목록”을 만드는 주체가 필요함.

- 두 가지 흐름:
  - **A. 대화 데이터가 버튼 정보를 들고 있음**  
    DialogueData(또는 대화 1건을 나타내는 에셋/행)에 “이 대화일 때 보여줄 버튼 목록”이 포함.
  - **B. 대화를 시작하는 코드가 버튼 목록을 만듦**  
    Npc나 DialogueManager가 “지금 상태(플래그, 퀘스트, 호감도 등)”를 보고 “이번에는 [선물, 퀘스트, 끝내기] 3개”처럼 목록을 만들어서 DialogueSystem에 넘김.

- **A**는 데이터 주도(기획/데이터로 버튼 구성을 바꿈), **B**는 코드 주도(상태에 따라 코드가 목록을 구성).  
  버튼 구성이 **대화 내용별로 고정**이면 A, **NPC/플레이어 상태에 따라 매번 달라지면** B가 맞음.  
  지금처럼 “같은 NPC라도 퀘스트 수락 가능/제출 가능/둘 다 없음”에 따라 버튼이 달라지므로 **B가 더 잘 맞음**.  
  나중에 “이 대화에서는 무조건 선물 버튼만”처럼 **대화별 고정**이 많아지면, 그때는 A(데이터에 버튼 목록)를 섞어도 됨.

---

## 3. “정보”를 어떤 형태로 들고 있느냐

- **옵션 1: 구조체/클래스 하나로 “버튼 1개 정보”**  
  예: `DialogueButtonInfo { string Label; DialogueActionType ActionType; }`  
  대화를 열 때 `List<DialogueButtonInfo>` 또는 배열을 넘김.  
  UI는 이 리스트 길이만큼 버튼 프리팹을 생성하고, 순서대로 라벨 붙이고, 클릭 시 ActionType만 이벤트로 발행.  
  **관리**: “버튼 정보 목록을 누가 만드느냐”만 정하면 됨 (위에서 말한 B면 Npc 또는 DialogueManager 쪽에서 리스트 생성).

- **옵션 2: 액션 타입만 넘기고, 라벨은 UI/데이터에서 조회**  
  “이번 대화 버튼: [GiveGift, QuestOffer, End]”처럼 **타입만** 넘김.  
  라벨("호감도 선물증정" 등)은 DialogueUI 또는 별도 테이블/스크립터블에서 “액션 타입 → 표시 텍스트”로 가져옴.  
  **관리**: 텍스트 변경은 데이터/로컬만 수정하면 되고, 코드는 타입만 다룸. 다만 “이 NPC만 이 버튼 라벨을 다르게” 같은 건 별도 규칙이 필요.

- **옵션 3: 스크립터블/테이블로 “버튼 종류” 정의**  
  “선물증정”, “퀘스트 제공”, “대화 끝내기”를 각각 스크립터블 한 행(또는 ID)으로 두고, 대화를 열 때 “이번에 쓸 버튼 ID 목록”만 넘김.  
  UI는 ID로 프리팹 생성하고, 라벨/아이콘은 그 스크립터블에서 로드.  
  **관리**: 기획이 버튼 텍스트/아이콘을 바꾸기 좋음. 반대로 “지금 상태에 따라 동적으로 목록을 만드는” 부분은 코드에 남음.

---

## 4. 정리 제안 (당신 아이디어에 맞춤)

- **버튼 프리팹 1종 + “대화창 띄울 때 버튼 N개 정보를 넘긴다”**는 방향이면:
  - **넘기는 정보**: `List<DialogueButtonInfo>` 같은 형태.  
    각 항목: **표시 텍스트**(또는 액션 타입만 두고 텍스트는 조회), **액션 타입(enum 등)**.
  - **이 목록을 만드는 주체**:  
    지금처럼 NPC/상태에 따라 달라지므로, **대화를 시작하는 시점의 코드**(Npc.Interact 쪽이든, “대화 시작을 준비하는 한 단계”든)에서  
    “지금 가능한 액션들”을 판단해서 **순서까지 포함한 리스트**를 만들어서 DialogueSystem.StartDialogue(..., buttonInfos) 처럼 넘기면 됨.
  - **관리 포인트**:
    - “위에서부터 호감도 선물, 퀘스트 제공, 대화 끝내기” 같은 **순서 규칙**을 한 곳(상수 리스트나 규칙 함수)에 두면, 나중에 “항상 끝내기는 맨 아래” 같은 정책을 바꾸기 쉬움.
    - “어떤 액션을 보여줄지” 판단(퀘스트 수락 가능한지, 제출 가능한지, 선물 가능한지)은 **지금도 DialogueManager/Npc에 흩어져 있는 그 로직**을, **“버튼 정보 목록을 만드는 함수” 하나**로 모으면 됨.  
      예: `GetDialogueButtonInfos(npcId, currentDialogueData) → List<DialogueButtonInfo>`.

- **데이터로 관리하고 싶다면**:  
  “이 대화(에셋/행)에서 사용 가능한 버튼 ID 목록”을 DialogueData에 넣고,  
  실제로 **지금 상태에서 보여줄지 여부**만 코드에서 걸러서, 최종 `List<DialogueButtonInfo>`를 만들어서 UI에 넘기는 식으로 반쯤 데이터·반쯤 코드로 나눌 수 있음.

이렇게 “버튼 정보 = 목록(순서 포함)”으로 고정해 두고, “그 목록을 누가 어떤 규칙으로 채우느냐”만 정하면, 관리가 한 군데로 모인다고 본다.

# 의견: 대화창 버튼이 계속 바뀌는 문제

대화창 UI는 크게 안 바뀌지만, **버튼**은 NPC/상황마다 달라질 수 있다는 전제에서의 설계 의견 정리.

---

## 1. 상황 정리

- **공통**: 대화 끝내기 버튼 → 거의 모든 NPC에 포함.
- **상황에 따라**: 퀘스트 수락, 퀘스트 제출, 선물 주기(호감도), 그 외 액션 등이 **조합·추가**될 수 있음.
- 즉, “필요한 버튼 집합”이 대화마다 다르고, 앞으로도 종류가 늘어날 수 있음.

---

## 2. 해결 방향 후보

### (1) 고정 슬롯 + 라벨/가시성만 바꾸기

- 대화창에 **액션 버튼 슬롯을 2~3개** 고정해 두고, 대화를 열 때마다  
  “슬롯 1: 텍스트 + 보이기/숨기기 + 클릭 시 할 일”만 넘겨 주는 방식.
- **장점**: 구현 단순, 레이아웃 고정.  
- **단점**: 슬롯 수보다 많은 액션을 한 번에 보여줘야 하면 맞지 않음. “최대 동시 액션 개수”를 미리 정해야 함.

---

### (2) “액션 목록”을 넘기고, UI는 그만큼만 그리기

- 대화 시작 시 **버튼 정보 목록**을 넘김.  
  예: `List<DialogueButtonInfo> { { "퀘스트 수락", QuestAccept }, { "대화 끝내기", End } }`.
- UI는 이 목록 길이만큼 버튼을 만들거나, 풀링된 버튼을 보이게 함.
- **장점**: 버튼 종류가 늘어나도 “목록에 하나 더 추가”만 하면 됨. 동시에 보이는 개수도 유연함.  
- **단점**: 동적 레이아웃(버튼 개수에 따라 위치 정렬)을 한 번 구현해야 함.

---

### (3) 액션 타입(enum/ID) + 한 곳에서 핸들러 연결

- 버튼을 **“종류”**로만 표현.  
  예: `DialogueActionType.End`, `QuestAccept`, `QuestSubmit`, `GiveGift` …
- 대화를 열 때 “이번 대화에서 보여줄 액션 목록”만 넘김.  
  예: `[End, QuestAccept]`.
- **어떤 버튼이 어떤 텍스트/아이콘을 쓰는지**는 UI 또는 설정(데이터)에서 “액션 타입 → 라벨/아이콘” 매핑.
- **클릭 시 동작**은 **한 곳**(예: PlayScene이나 전용 Handler)에서 `DialogueSystem.OnDialogueActionRequested(ActionType)` 같은 이벤트를 구독해, 타입별로 분기해서 처리.
- **장점**:  
  - 새 버튼 종류 추가 = enum/ID 하나 추가 + 핸들러 한 분기 + (선택) 라벨 매핑 추가.  
  - 대화 로직은 “지금 가능한 액션 목록”만 알려 주고, “그걸 누르면 무슨 일을 할지”는 연결부에서만 알고 있음.  
- **단점**: 액션 타입 정의와 핸들러 등록 구조를 한 번 설계해야 함.

---

### (4) 데이터(스크립터블/테이블)로 “대화 액션” 정의

- “선물 주기”, “퀘스트 수락” 같은 것을 **스크립터블 오브젝트나 테이블 한 행**으로 정의.  
  (ID, 표시 텍스트, 아이콘, 조건 등.)
- 대화 시작 시 “이 NPC/이 대화에서 사용 가능한 액션 ID 목록”만 넘기고, UI는 ID로 버튼을 그림.
- 클릭 시 “액션 ID”만 이벤트로 발행하고, 구독처에서 ID별로 실제 로직(퀘스트 수락, 선물, 종료 등) 수행.
- **장점**: 기획/데이터로 버튼 추가 가능, 확장성 가장 좋음.  
- **단점**: 초기 구조가 가장 무거움. 지금 규모에서는 과할 수 있음.

---

## 3. 추천 흐름 (지금 프로젝트 기준)

- **당장**:  
  - “대화 끝내기”는 **항상 1개 고정**.  
  - 그 옆에 **“추가 액션” 슬롯 1~2개**를 두고,  
    지금처럼 “퀘스트 수락/제출”은 그 슬롯의 **텍스트 + 클릭 시 이벤트**만 바꿔서 쓰기.  
  → 지금 구조를 크게 바꾸지 않고, “나중에 선물 주기”도 같은 슬롯에 “텍스트만 바꿔서” 붙일 수 있음.

- **버튼 종류가 3~4개 이상으로 늘어나면**:  
  - **(3) 액션 타입(enum) + “가능한 액션 목록” 전달 + 한 곳에서 이벤트로 핸들러 연결**으로 넘어가는 걸 추천.  
  - 그러면 DialogueUI는 “버튼 목록을 받아서 그리기 + 클릭 시 액션 타입만 이벤트로 발행”만 담당하고,  
    “퀘스트 수락 / 제출 / 선물 / …”는 모두 **한 곳(이벤트 구독처)**에서만 처리할 수 있어서, 앞에서 정리한 “한 곳에서 처리” 원칙과도 잘 맞음.

- **진짜 버튼/액션이 많아지고 기획이 바뀌는 게 잦아지면**  
  - 그때 (4)처럼 “액션 ID + 데이터”로 올리는 걸 고려해도 늦지 않음.

---

## 4. 한 줄 요약

- **지금 단계**: 끝내기 버튼 고정 + “추가 액션” 슬롯 1~2개로 퀘스트/선물 등 텍스트·이벤트만 바꿔서 재사용.
- **조금 더 늘어나면**: “이번 대화에서 가능한 액션 목록”을 넘기고, 클릭은 **액션 타입 이벤트**로만 발행 → **한 곳에서만** 타입별 처리로 정리.

이렇게 가면 대화창 UI는 거의 안 바꾸고, 버튼만 “데이터/목록 + 이벤트”로 확장할 수 있다고 본다.
